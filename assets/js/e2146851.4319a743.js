"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[597],{3905:(t,e,r)=>{r.d(e,{Zo:()=>m,kt:()=>u});var n=r(7294);function a(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function o(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function l(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?o(Object(r),!0).forEach((function(e){a(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function i(t,e){if(null==t)return{};var r,n,a=function(t,e){if(null==t)return{};var r,n,a={},o=Object.keys(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||(a[r]=t[r]);return a}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(a[r]=t[r])}return a}var s=n.createContext({}),p=function(t){var e=n.useContext(s),r=e;return t&&(r="function"==typeof t?t(e):l(l({},e),t)),r},m=function(t){var e=p(t.components);return n.createElement(s.Provider,{value:e},t.children)},d="mdxType",c={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},f=n.forwardRef((function(t,e){var r=t.components,a=t.mdxType,o=t.originalType,s=t.parentName,m=i(t,["components","mdxType","originalType","parentName"]),d=p(r),f=a,u=d["".concat(s,".").concat(f)]||d[f]||c[f]||o;return r?n.createElement(u,l(l({ref:e},m),{},{components:r})):n.createElement(u,l({ref:e},m))}));function u(t,e){var r=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var o=r.length,l=new Array(o);l[0]=f;var i={};for(var s in e)hasOwnProperty.call(e,s)&&(i[s]=e[s]);i.originalType=t,i[d]="string"==typeof t?t:a,l[1]=i;for(var p=2;p<o;p++)l[p]=r[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},3040:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=r(7462),a=(r(7294),r(3905));const o={},l="XML",i={unversionedId:"response_body/text/xml_text",id:"response_body/text/xml_text",title:"XML",description:"Restonomer can parse the api response of text type in XML format. User need to configure the checkpoint in below format:",source:"@site/docs/response_body/text/xml_text.md",sourceDirName:"response_body/text",slug:"/response_body/text/xml_text",permalink:"/restonomer/docs/response_body/text/xml_text",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JSON",permalink:"/restonomer/docs/response_body/text/json_text"},next:{title:"Cursor Based Pagination",permalink:"/restonomer/docs/pagination/cursor_based_pagination"}},s={},p=[{value:"Compression",id:"compression",level:2},{value:"XML Text Format Configurations",id:"xml-text-format-configurations",level:2}],m={toc:p},d="wrapper";function c(t){let{components:e,...r}=t;return(0,a.kt)(d,(0,n.Z)({},m,r,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"xml"},"XML"),(0,a.kt)("p",null,"Restonomer can parse the api response of text type in XML format. User need to configure the checkpoint in below format:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-hocon"},'name = "checkpoint_xml_response_dataframe_converter"\n\ndata = {\n  data-request = {\n    url = "http://localhost:8080/xml-response-converter"\n  }\n\n  data-response = {\n    body = {\n      type = "Text"\n      text-format = {\n        type = "XMLTextFormat"\n        row-tag = "ROW"\n      }\n    }\n\n    persistence = {\n      type = "LocalFileSystem"\n      file-format = {\n        type = "ParquetFileFormat"\n      }\n      file-path = "/tmp/response_body"\n    }\n  }\n}\n')),(0,a.kt)("h2",{id:"compression"},"Compression"),(0,a.kt)("p",null,"In case the xml text that is returned by the api is compressed, user can configure the checkpoint in below format:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-hocon"},'name = "checkpoint_xml_response_dataframe_converter"\n\ndata = {\n  data-request = {\n    url = "http://localhost:8080/xml-response-converter"\n  }\n\n  data-response = {\n    body = {\n      type = "Text"\n      compression = "GZIP"\n      text-format = {\n        type = "XMLTextFormat"\n        row-tag = "ROW"\n      }\n    }\n\n    persistence = {\n      type = "LocalFileSystem"\n      file-format = {\n        type = "ParquetFileFormat"\n      }\n      file-path = "/tmp/response_body"\n    }\n  }\n}\n')),(0,a.kt)("p",null,"As of now, restonomer supports only ",(0,a.kt)("inlineCode",{parentName:"p"},"GZIP")," compression format."),(0,a.kt)("h2",{id:"xml-text-format-configurations"},"XML Text Format Configurations"),(0,a.kt)("p",null,"Just like ",(0,a.kt)("inlineCode",{parentName:"p"},"row-tag"),", user can configure below other properties for XML text format that will help restonomer for\nparsing:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:"left"},"Parameter Name"),(0,a.kt)("th",{parentName:"tr",align:"center"},"Default Value"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"attribute-prefix"),(0,a.kt)("td",{parentName:"tr",align:"center"},"_"),(0,a.kt)("td",{parentName:"tr",align:"left"},"The prefix for attributes so that we can differentiate attributes and elements.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"charset"),(0,a.kt)("td",{parentName:"tr",align:"center"},"UTF-8"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Defaults to 'UTF-8' but can be set to other valid charset names.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"column-name-of-corrupt-record"),(0,a.kt)("td",{parentName:"tr",align:"center"},"_corrupt_record"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Allows renaming the new field having malformed string created by PERMISSIVE mode. This overrides spark.sql.columnNameOfCorruptRecord.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"date-format"),(0,a.kt)("td",{parentName:"tr",align:"center"},"yyyy-MM-dd"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Sets the string that indicates a date format.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"exclude-attribute"),(0,a.kt)("td",{parentName:"tr",align:"center"},"false"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Whether you want to exclude attributes in elements or not.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"ignore-surrounding-spaces"),(0,a.kt)("td",{parentName:"tr",align:"center"},"false"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Defines whether or not surrounding whitespaces from values being read should be skipped.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"ignore-namespace"),(0,a.kt)("td",{parentName:"tr",align:"center"},"false"),(0,a.kt)("td",{parentName:"tr",align:"left"},"If true, namespaces prefixes on XML elements and attributes are ignored. ",(0,a.kt)("br",null),"Note that, at the moment, namespaces cannot be ignored on the rowTag element, only its children. ",(0,a.kt)("br",null),"Note that XML parsing is in general not namespace-aware even if false.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"infer-schema"),(0,a.kt)("td",{parentName:"tr",align:"center"},"true"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Infers the input schema automatically from data.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"mode"),(0,a.kt)("td",{parentName:"tr",align:"center"},"FAILFAST"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Allows a mode for dealing with corrupt records during parsing. Allowed values are PERMISSIVE, DROPMALFORMED and FAILFAST.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"null-value"),(0,a.kt)("td",{parentName:"tr",align:"center"},"null"),(0,a.kt)("td",{parentName:"tr",align:"left"},"The value to read as a null value.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"row-tag"),(0,a.kt)("td",{parentName:"tr",align:"center"},"row"),(0,a.kt)("td",{parentName:"tr",align:"left"},"The row tag of your XML files to treat as a row.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"sampling-ratio"),(0,a.kt)("td",{parentName:"tr",align:"center"},"1.0"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Defines fraction of rows used for schema inferring.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"timestamp-format"),(0,a.kt)("td",{parentName:"tr",align:"center"},"yyyy-MM-dd HH:mm:ss"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Sets the string that indicates a timestamp format.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"value-tag"),(0,a.kt)("td",{parentName:"tr",align:"center"},"_VALUE"),(0,a.kt)("td",{parentName:"tr",align:"left"},"The tag used for the value when there are attributes in the element having no child.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},"wildcard-col-name"),(0,a.kt)("td",{parentName:"tr",align:"center"},"xs_any"),(0,a.kt)("td",{parentName:"tr",align:"left"},"Name of a column existing in the provided schema which is interpreted as a 'wildcard'. It must have type string or array of strings. ",(0,a.kt)("br",null),"It will match any XML child element that is not otherwise matched by the schema. The XML of the child becomes the string value of the column. ",(0,a.kt)("br",null),"If an array, then all unmatched elements will be returned as an array of strings. As its name implies, it is meant to emulate XSD's xs:any type.")))))}c.isMDXComponent=!0}}]);