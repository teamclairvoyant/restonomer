"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2502],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>g});var r=a(7294);function n(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function i(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,r)}return a}function l(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?i(Object(a),!0).forEach((function(e){n(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,r,n=function(t,e){if(null==t)return{};var a,r,n={},i=Object.keys(t);for(r=0;r<i.length;r++)a=i[r],e.indexOf(a)>=0||(n[a]=t[a]);return n}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)a=i[r],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(n[a]=t[a])}return n}var s=r.createContext({}),p=function(t){var e=r.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):l(l({},e),t)),a},m=function(t){var e=p(t.components);return r.createElement(s.Provider,{value:e},t.children)},d="mdxType",c={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},f=r.forwardRef((function(t,e){var a=t.components,n=t.mdxType,i=t.originalType,s=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),d=p(a),f=n,g=d["".concat(s,".").concat(f)]||d[f]||c[f]||i;return a?r.createElement(g,l(l({ref:e},m),{},{components:a})):r.createElement(g,l({ref:e},m))}));function g(t,e){var a=arguments,n=e&&e.mdxType;if("string"==typeof t||n){var i=a.length,l=new Array(i);l[0]=f;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o[d]="string"==typeof t?t:n,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}f.displayName="MDXCreateElement"},5106:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=a(7462),n=(a(7294),a(3905));const i={},l="CSV",o={unversionedId:"response_body/text/csv_text",id:"response_body/text/csv_text",title:"CSV",description:"Restonomer can parse the api response of text type in CSV format. User need to configure the checkpoint in below format:",source:"@site/docs/response_body/text/csv_text.md",sourceDirName:"response_body/text",slug:"/response_body/text/csv_text",permalink:"/restonomer/docs/response_body/text/csv_text",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Retry Mechanism",permalink:"/restonomer/docs/restonomer_retry"},next:{title:"HTML Table",permalink:"/restonomer/docs/response_body/text/html_text"}},s={},p=[{value:"Compression",id:"compression",level:2},{value:"CSV Text Format Configurations",id:"csv-text-format-configurations",level:2}],m={toc:p},d="wrapper";function c(t){let{components:e,...a}=t;return(0,n.kt)(d,(0,r.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"csv"},"CSV"),(0,n.kt)("p",null,"Restonomer can parse the api response of text type in CSV format. User need to configure the checkpoint in below format:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-hocon"},'name = "checkpoint_csv_response_dataframe_converter"\n\ndata = {\n  data-request = {\n    url = "http://localhost:8080/csv-response-converter"\n  }\n\n  data-response = {\n    body = {\n      type = "Text"\n      text-format = {\n        type = "CSVTextFormat"\n        sep = ";"\n      }\n    }\n\n    persistence = {\n      type = "LocalFileSystem"\n      file-format = {\n        type = "ParquetFileFormat"\n      }\n      file-path = "/tmp/response_body"\n    }\n  }\n}\n')),(0,n.kt)("h2",{id:"compression"},"Compression"),(0,n.kt)("p",null,"In case the csv text that is returned by the api is compressed, user can configure the checkpoint in below format:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-hocon"},'name = "checkpoint_csv_response_dataframe_converter"\n\ndata = {\n  data-request = {\n    url = "http://localhost:8080/csv-response-converter"\n  }\n\n  data-response = {\n    body = {\n      type = "Text"\n      compression = "GZIP"\n      text-format = {\n        type = "CSVTextFormat"\n        sep = ";"\n      }\n    }\n\n    persistence = {\n      type = "LocalFileSystem"\n      file-format = {\n        type = "ParquetFileFormat"\n      }\n      file-path = "/tmp/response_body"\n    }\n  }\n}\n')),(0,n.kt)("p",null,"As of now, restonomer supports only ",(0,n.kt)("inlineCode",{parentName:"p"},"GZIP")," compression format."),(0,n.kt)("h2",{id:"csv-text-format-configurations"},"CSV Text Format Configurations"),(0,n.kt)("p",null,"Just like ",(0,n.kt)("inlineCode",{parentName:"p"},"sep"),", user can configure below other properties for CSV text format that will help restonomer for parsing:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Parameter Name"),(0,n.kt)("th",{parentName:"tr",align:"center"},"Default Value"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"char-to-escape-quote-escaping"),(0,n.kt)("td",{parentName:"tr",align:"center"},"\\ "),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets a single character used for escaping the escape for the quote character.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"column-name-of-corrupt-record"),(0,n.kt)("td",{parentName:"tr",align:"center"},"_corrupt_record"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Allows renaming the new field having malformed string created by PERMISSIVE mode. ",(0,n.kt)("br",null),"This overrides ",(0,n.kt)("inlineCode",{parentName:"td"},"spark.sql.columnNameOfCorruptRecord"),".")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"comment"),(0,n.kt)("td",{parentName:"tr",align:"center"},"#"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets a single character used for skipping lines beginning with this character.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"date-format"),(0,n.kt)("td",{parentName:"tr",align:"center"},"yyyy-MM-dd"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string that indicates a date format.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"empty-value"),(0,n.kt)("td",{parentName:"tr",align:"center"},'"" (empty string)'),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string representation of an empty value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"enable-date-time-parsing-fallback"),(0,n.kt)("td",{parentName:"tr",align:"center"},"true"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Allows falling back to the backward compatible (Spark 1.x and 2.0) behavior of parsing dates and timestamps ",(0,n.kt)("br",null),"if values do not match the set patterns.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"encoding"),(0,n.kt)("td",{parentName:"tr",align:"center"},"UTF-8"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Decodes the CSV files by the given encoding type.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"enforce-schema"),(0,n.kt)("td",{parentName:"tr",align:"center"},"true"),(0,n.kt)("td",{parentName:"tr",align:"left"},"If it is set to true, the specified or inferred schema will be forcibly applied to datasource files, and headers in CSV files will be ignored. ",(0,n.kt)("br",null),"If the option is set to false, the schema will be validated against all headers in CSV files in the case when the header option is set to true. ",(0,n.kt)("br",null),"Field names in the schema and column names in CSV headers are checked by their positions taking into account spark.sql.caseSensitive. ",(0,n.kt)("br",null),"Though the default value is true, it is recommended to disable the enforce-schema option to avoid incorrect results.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"escape"),(0,n.kt)("td",{parentName:"tr",align:"center"},"\\ "),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets a single character used for escaping quotes inside an already quoted value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"header"),(0,n.kt)("td",{parentName:"tr",align:"center"},"true"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Boolean flag to tell whether csv text contains header names or not.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"infer-schema"),(0,n.kt)("td",{parentName:"tr",align:"center"},"true"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Infers the input schema automatically from data.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"ignore-leading-white-space"),(0,n.kt)("td",{parentName:"tr",align:"center"},"false"),(0,n.kt)("td",{parentName:"tr",align:"left"},"A flag indicating whether or not leading whitespaces from values being read should be skipped.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"ignore-trailing-white-space"),(0,n.kt)("td",{parentName:"tr",align:"center"},"false"),(0,n.kt)("td",{parentName:"tr",align:"left"},"A flag indicating whether or not trailing whitespaces from values being read should be skipped.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"line-sep"),(0,n.kt)("td",{parentName:"tr",align:"center"},"\\n"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Defines the line separator that should be used for parsing. Maximum length is 1 character.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"locale"),(0,n.kt)("td",{parentName:"tr",align:"center"},"en-US"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets a locale as a language tag in IETF BCP 47 format. For instance, this is used while parsing dates and timestamps.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"max-chars-per-column"),(0,n.kt)("td",{parentName:"tr",align:"center"},"-1"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Defines the maximum number of characters allowed for any given value being read.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"max-columns"),(0,n.kt)("td",{parentName:"tr",align:"center"},"20480"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Defines a hard limit of how many columns a record can have.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"mode"),(0,n.kt)("td",{parentName:"tr",align:"center"},"FAILFAST"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Allows a mode for dealing with corrupt records during parsing. Allowed values are PERMISSIVE, DROPMALFORMED, and FAILFAST.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"multi-line"),(0,n.kt)("td",{parentName:"tr",align:"center"},"false"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Parse one record, which may span multiple lines, per file.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"nan-value"),(0,n.kt)("td",{parentName:"tr",align:"center"},"NaN"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string representation of a non-number value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"negative-inf"),(0,n.kt)("td",{parentName:"tr",align:"center"},"-Inf"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string representation of a negative infinity value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"null-value"),(0,n.kt)("td",{parentName:"tr",align:"center"},"null"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string representation of a null value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"positive-inf"),(0,n.kt)("td",{parentName:"tr",align:"center"},"Inf"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string representation of a positive infinity value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"prefer-date"),(0,n.kt)("td",{parentName:"tr",align:"center"},"true"),(0,n.kt)("td",{parentName:"tr",align:"left"},"During schema inference (infer-schema), attempts to infer string columns that contain dates as Date if the values satisfy the date-format option or the default date format. ",(0,n.kt)("br",null),"For columns that contain a mixture of dates and timestamps, try inferring them as TimestampType if the timestamp format is not specified; otherwise, infer them as StringType.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"quote"),(0,n.kt)("td",{parentName:"tr",align:"center"},'"'),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets a single character used for escaping quoted values where the separator can be part of the value. ",(0,n.kt)("br",null),"For reading, if you would like to turn off quotations, you need to set not null but an empty string.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"record-sep"),(0,n.kt)("td",{parentName:"tr",align:"center"},"\\n"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Delimiter by which rows are separated in a CSV text.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"sampling-ratio"),(0,n.kt)("td",{parentName:"tr",align:"center"},"1.0"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Defines the fraction of rows used for schema inferring.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"sep"),(0,n.kt)("td",{parentName:"tr",align:"center"},","),(0,n.kt)("td",{parentName:"tr",align:"left"},"Delimiter by which fields in a row are separated in a CSV text.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"timestamp-format"),(0,n.kt)("td",{parentName:"tr",align:"center"},"yyyy-MM-dd HH:mm:ss"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string that indicates a timestamp format.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"timestamp-ntz-format"),(0,n.kt)("td",{parentName:"tr",align:"center"},"yyyy-MM-dd'T'HH:mm:ss","[.SSS]"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Sets the string that indicates a timestamp without timezone format.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"unescaped-quote-handling"),(0,n.kt)("td",{parentName:"tr",align:"center"},"STOP-AT-DELIMITER"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Defines how the CsvParser will handle values with unescaped quotes. ",(0,n.kt)("br",null)," Allowed values are STOP-AT-CLOSING-QUOTE, BACK-TO-DELIMITER, STOP-AT-DELIMITER, SKIP-VALUE, RAISE-ERROR")))))}c.isMDXComponent=!0}}]);